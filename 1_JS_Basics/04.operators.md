# 4. Операторы

### 4.1. Математические операторы.
```
    +, -     - сложение / вычитание, инкремент / декремент
    *, /     - умножение / деление
    %        - остаток от деления (https://ru.wikipedia.org/wiki/Деление_с_остатком)
    **       - возведение в степень
```

См. примеры

### 4.2. Операторы сравнения.

```
    ==, ===, !=, !== - равенство / неравенство (строгое)
    >, >=, <, <=     - больше (либо равно), меньше (либо равно)
```

См. примеры

### 4.3. Логические операторы.

```
    && - И
    || - ИЛИ
    !  - НЕ
```

##### Логическое И (&&):

| AND       | true    | false |
|-----------|:-------:|:-----:|
| **true**  | true    | false |
| **false** | false   | true  |


##### Логическое ИЛИ (||):

| OR        | true    | false |
|-----------|:-------:|:-----:|
| **true**  | true    | true  |
| **false** | true    | false |

См. примеры

### 4.4. Побитовые операции, сдвиги

##### Побитовое ИЛИ (|):

|    bin  |   bin |  dec   |
|:-------:|:-----:|:------:|
| 0       | 1     |= **1** |
| 1       | 0     |= **2** |
| 1       | 1     |= **3** |

##### Побитовое И (&):

|    bin  |   bin |  dec   |
|:-------:|:-----:|:------:|
| 1       | 1     |= **1** |
| 1       | 0     |= **2** |
| 1       | 0     |= **2** |

##### Побитовое исключающее ИЛИ	(^)

|    bin  |   bin |  dec   |
|:-------:|:-----:|:------:|
| 1       | 1     |= **1** |
| 1       | 0     |= **2** |
| 1       | 0     |= **2** |

##### Побитовое НЕ (~)

~~Операнды всех битовых операций конвертируются в 32-х битовые целые со знаком представленные 
в дополнительном коде и с использованием порядка битов от "старшего к младшему". 
Порядок битов "от старшего к младшему" означает, что наиболее значимый бит 
(бит с наибольшим значением) находится слева если 32-х разрядное число представлено в виде 
горизонтальной линии (шкалы). Представление в дополнительном коде означает, что отрицательное 
значение числа (например 5 и -5) получается путем инвертирования числа 
(операция "побитовое НЕ", также известное как "обратный код") и прибавления к нему единицы.~~

## **Всё сложно!**

Число 0 есть число, у которого во ввсех битовых позициях записаны нули.
```
0 (base 10) = 00000000000000000000000000000000 (base 2)
```
Число -1 есть число, у которого во всех битовых позициях записаны единицы. 
```
-1 (base 10) = 11111111111111111111111111111111 (base 2)
```

Из-за внутреннего представления отрицательных чисел получается так, что:
<pre>~n == -(n+1)</pre>

```
9 (по осн. 10)
  = 00000000000000000000000000001001 (по осн. 2)
               --------------------------------
~9 (по осн. 10)
  = 11111111111111111111111111110110 (по осн. 2)
  = -10 (по осн. 10)
```

##### Побитовый сдвиг влево (<<)

```
1 (по осн. 10)
  = 00000000000000000000000000000001 (по осн. 2)
               --------------------------------
<< 1
  = 00000000000000000000000000000010 (по осн. 2)
  = 2 (по осн. 10)
```

##### Побитовый сдвиг вправо, переносящий знак (>>)

```
2 (по осн. 10)
  = 00000000000000000000000000000010 (по осн. 2)
               --------------------------------
>> 1
  = 00000000000000000000000000000001 (по осн. 2)
  = 1 (по осн. 10)
```

##### Побитовый сдвиг вправо, с заполнением нулями (>>>)

```
-10 (по осн. 10)
  = 11111111111111111111111111110110 (по осн. 2)
               --------------------------------
>> 1
  = 1111111111111111111111111111011 (по осн. 2)
  = 2147483643 (по осн. 10)
```

### 4.5. nullish

```
let b = null;
let a = b ?? 1;
```
См. примеры

### 4.6. optional chaining

```
object.a?.c?.d
```

См. примеры

### 4.7. spread / rest operator

```
let res, args = [1, 2, 3];

function sum(...args) {
  console.log(args);
}

sum(...args);

res = [...arr1, ...arr2];

res = { ...obj1, ...obj2 };
```

См. примеры

### 4.8. destructuring assignment

```
let { a, b, ...rest } = { a: 1, b: 2, c: 3, d: 4 };
```

См. примеры