# 3. Типы данных

![JS Types](https://github.com/llevkin/katacoda-scenarios/blob/master/1_JS_Basics/img/js_types.jpg?raw=true)

JavaScript позволяет нам работать с примитивными типами данных – строками,
числами и т.д., как будто они являются объектами. У них есть и методы.
Мы изучим их позже, а сначала разберём, как это всё работает, потому что, 
конечно, примитивы – не объекты.

Давайте взглянем на ключевые различия между примитивами и объектами.

##### Примитив:

- Это – значение «примитивного» типа.
- Есть 6 примитивных типов: string, number, boolean, symbol, null и undefined.

##### Объект:

- Может хранить множество значений как свойства.
- Объявляется при помощи фигурных скобок {}, например: {name: "Рома", age: 30}. В JavaScript есть и другие виды объектов: например, функции тоже являются объектами.

Существует множество встроенных объектов. Например, те, которые работают с датами, ошибками и т.д. Они имеют различные свойства и методы.

Однако у этих возможностей есть обратная сторона!

Объекты «тяжелее» примитивов. Они нуждаются в дополнительных ресурсах для поддержания внутренней структуры.

##### Примитив как объект

Вот парадокс, с которым столкнулся создатель JavaScript:

- Есть много всего, что хотелось бы сделать с примитивами, такими как строка или число. Было бы замечательно, если бы мы могли работать с ними через вызовы методов.
- Примитивы должны быть лёгкими и быстрыми.

##### Выбранное решение, хотя выглядит оно немного неуклюже:

- Примитивы остаются примитивами. Одно значение, как и хотелось.
- Язык позволяет осуществлять доступ к методам и свойствам строк, чисел, булевых значений и символов.
- Чтобы это работало, при таком доступе создаётся специальный «объект-обёртка», который предоставляет нужную функциональность, а после удаляется.

Каждый примитив имеет свой собственный «объект-обёртку», которые называются: String, Number, Boolean и Symbol. Таким образом, они имеют разный набор методов.

См. пример.

Движок JavaScript сильно оптимизирует этот процесс. Он даже может пропустить создание специального объекта. Однако, он всё же должен придерживаться спецификаций и работать так, как будто он его создаёт.

Конструкторы **String**, **Number**, **Boolean** предназначены только для внутреннего пользования, у **Symbol** конструктор - отсутствует.

Некоторые языки, такие как Java, позволяют явное создание «объектов-обёрток» для примитивов при помощи такого синтаксиса как new Number(1) или new Boolean(false).

В JavaScript, это тоже возможно по историческим причинам, но очень не рекомендуется. В некоторых местах последствия могут быть катастрофическими.

См. пример.

### 3.1. Boolean

См. пример.

### 3.2. String

В JavaScript любые текстовые данные являются строками.
Внутренний формат для строк — всегда UTF-16, вне зависимости от кодировки страницы.

##### Кавычки

В JavaScript есть разные типы кавычек.
Строку можно создать с помощью одинарных, двойных либо обратных кавычек.
Одинарные и двойные кавычки работают, по сути, одинаково и экранируют друг-друга.
При использовании обратных кавычек в такую строку мы сможем вставлять произвольные выражения, обернув их в ${…}

См. пример.

### 3.3. Number

 - Обычные числа в JavaScript хранятся в 64-битном формате IEEE-754, который также называют «числа с плавающей точкой двойной точности» (double precision floating point numbers)
 
 - Диапазон значений от <code>-2^53</code> до <code>2^53</code> 
 
##### Неточные вычисления:

- Внутри JavaScript число представлено в виде 64-битного формата IEEE-754. Для хранения числа используется 64 бита: 52 из них используется для хранения цифр, 11 из них для хранения положения десятичной точки (если число целое, то хранится 0), и один бит отведён на хранение знака.

- Если число слишком большое, оно переполнит 64-битное хранилище, JavaScript вернёт бесконечность

 ##### 3.3.5 NaN
 
 - Метод Number.isNaN() определяет, является ли переданное значение NaN. Это более надёжная версия оригинальной глобальной функции isNaN().
 
 - Поскольку оба оператора проверки на равенство, == и ===, вычисляются в false при проверке, что NaN и есть NaN, появляется необходимость в функции Number.isNaN(). Эта ситуация отличается от всех других возможных сравнений в JavaScript.

 - В отличие от глобальной функции isNaN(), Number.isNaN() не имеет проблемы принудительного преобразования параметра в число. Это значит, что в него безопасно передавать значения, которые обычно превращаются в NaN, но на самом деле NaN не являются. Также это значит, что метод возвращает true только для числовых значений, имеющих значение NaN.
 
    ```
    Number.isNaN(NaN); // true
    Number.isNaN(Number.NaN); // true
    Number.isNaN(0 / 0) // true

    // При использовании глобальной функции isNaN() это всё будет true
    Number.isNaN('NaN');      // false
    Number.isNaN(undefined);  // false
    Number.isNaN({});         // false
    Number.isNaN('blabla');   // false

    // А это всё в любом случае будет false
    Number.isNaN(true);
    Number.isNaN(null);
    Number.isNaN(37);
    Number.isNaN('37');
    Number.isNaN('37.37');
    Number.isNaN('');
    Number.isNaN(' ');
    ```
 

```
console.log(1e500); // Infinity
```

См. пример.

### 3.4. Object

См. пример.

- #### 3.4.1. Array
    См. пример.
    
- #### 3.4.2. Date
    См. пример.
    
- #### 3.4.3. Function
    См. пример.
    
- #### 3.4.4. RegExp
    ```
    /pattern/flags
    ```
    
    ##### pattern
    
    - Текст регулярного выражения.
    
    ##### flags

    - Если определён, может принимать любую комбинацию нижеследующих значений:
    
    ```
        g - глобальное сопоставление
        i - игнорирование регистра при сопоставлении
        m - сопоставление по нескольким строкам; 
            символы начала и конца (^ и $) 
            начинают работать по нескольким строкам 
            (то есть, происходит сопоставление 
            с началом или концом каждой строки 
            (строки разделяются символами \n или \r),
            а не только с началом или концом 
            всей вводимой строки)
        y - «липкий» поиск; сопоставление в целевой 
            строке начинается с индекса, 
            на который указывает свойство lastIndex 
            этого регулярного выражения 
            (и не пытается сопоставиться с 
            любого более позднего индекса).
    ```

    См. пример.

- #### 3.4.5. Symbol
    
    - Символ (symbol) – примитивный тип данных, использующийся для создания 
      уникальных идентификаторов.

    - Символы создаются вызовом функции Symbol(), в которую можно передать 
      описание (имя) символа.
    
    - Даже если символы имеют одно и то же имя, это – разные символы. 
      Если мы хотим, чтобы одноимённые символы были равны, то следует 
      использовать глобальный реестр: вызов Symbol.for(key) возвращает 
      (или создаёт) глобальный символ с key в качестве имени. Многократные 
      вызовы команды Symbol.for с одним и тем же аргументом возвращают один 
      и тот же символ.
    
    - Символы имеют два основных варианта использования:
    
        - «Скрытые» свойства объектов. Если мы хотим добавить свойство в объект, 
          который «принадлежит» другому скрипту или библиотеке, мы можем создать 
          символ и использовать его в качестве ключа. Символьное свойство не 
          появится в for..in, так что оно не будет нечаянно обработано вместе с другими. 
          Также оно не будет модифицировано прямым обращением, так как другой скрипт не 
          знает о нашем символе. Таким образом, свойство будет защищено от случайной 
          перезаписи или использования.
    
        - Так что, используя символьные свойства, мы можем спрятать что-то нужное нам, 
          но что другие видеть не должны.
    
    - Существует множество системных символов, используемых внутри JavaScript, 
      доступных как Symbol.*. Мы можем использовать их, чтобы изменять встроенное 
      поведение ряда объектов. Например, использовать Symbol.iterator для итераторов, 
      Symbol.toPrimitive для настройки преобразования объектов в примитивы и так далее.
    
    - Технически символы скрыты не на 100%. Существует встроенный 
      метод Object.getOwnPropertySymbols(obj) – с его помощью можно
      получить все свойства объекта с ключами-символами. Также существует 
      метод Reflect.ownKeys(obj), который возвращает все ключи объекта, 
      включая символьные. Так что они не совсем спрятаны. Но большинство 
      библиотек, встроенных методов и синтаксических конструкций не 
      используют эти методы.

    См. пример.