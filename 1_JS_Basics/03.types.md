# 3. Типы данных

![JS Types](https://github.com/llevkin/katacoda-scenarios/blob/master/1_JS_Basics/img/js_types.jpg?raw=true)

JavaScript позволяет нам работать с примитивными типами данных – строками,
числами и т.д., как будто они являются объектами. У них есть и методы.
Мы изучим их позже, а сначала разберём, как это всё работает, потому что, 
конечно, примитивы – не объекты.

Давайте взглянем на ключевые различия между примитивами и объектами.

##### Примитив:

- Это – значение «примитивного» типа.
- Есть 6 примитивных типов: string, number, boolean, symbol, null и undefined.

##### Объект:

- Может хранить множество значений как свойства.
- Объявляется при помощи фигурных скобок {}, например: {name: "Рома", age: 30}. В JavaScript есть и другие виды объектов: например, функции тоже являются объектами.

Существует множество встроенных объектов. Например, те, которые работают с датами, ошибками и т.д. Они имеют различные свойства и методы.

Однако у этих возможностей есть обратная сторона!

Объекты «тяжелее» примитивов. Они нуждаются в дополнительных ресурсах для поддержания внутренней структуры.

##### Примитив как объект

Вот парадокс, с которым столкнулся создатель JavaScript:

- Есть много всего, что хотелось бы сделать с примитивами, такими как строка или число. Было бы замечательно, если бы мы могли работать с ними через вызовы методов.
- Примитивы должны быть лёгкими и быстрыми.

##### Выбранное решение, хотя выглядит оно немного неуклюже:

- Примитивы остаются примитивами. Одно значение, как и хотелось.
- Язык позволяет осуществлять доступ к методам и свойствам строк, чисел, булевых значений и символов.
- Чтобы это работало, при таком доступе создаётся специальный «объект-обёртка», который предоставляет нужную функциональность, а после удаляется.

Каждый примитив имеет свой собственный «объект-обёртку», которые называются: String, Number, Boolean и Symbol. Таким образом, они имеют разный набор методов.

См. пример.

Движок JavaScript сильно оптимизирует этот процесс. Он даже может пропустить создание специального объекта. Однако, он всё же должен придерживаться спецификаций и работать так, как будто он его создаёт.

Конструкторы **String**, **Number**, **Boolean** предназначены только для внутреннего пользования, у **Symbol** конструктор - отсутствует.

Некоторые языки, такие как Java, позволяют явное создание «объектов-обёрток» для примитивов при помощи такого синтаксиса как new Number(1) или new Boolean(false).

В JavaScript, это тоже возможно по историческим причинам, но очень не рекомендуется. В некоторых местах последствия могут быть катастрофическими.

См. пример.

### 3.1. Boolean

См. пример.

### 3.2. String

См. пример.

### 3.3. Number

См. пример.